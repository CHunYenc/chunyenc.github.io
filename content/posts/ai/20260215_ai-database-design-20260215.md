---
title: "你的查詢為什麼這麼慢？從資料庫設計看後端工程師的基本功"
description: "由 AI 生成的深度技術專題 — 資料庫不是黑盒子，理解你的查詢在底層如何執行，是後端工程師從 Junior 晉升的關鍵門檻。"
date: 2026-02-15T17:11:35+08:00
slug: "ai-database-design-20260215"
categories:
    - Experience
tags:
    - ai
math: false
license: CC BY-NC-SA 4.0
hidden: false
comments: true
draft: false
---

# 你的查詢為什麼這麼慢？從資料庫設計看後端工程師的基本功

身為後端工程師，CRUD 寫久了，難免會遇到查詢效能瓶頸。最常見的反應是：「加個索引試試看！」。但索引並非萬靈丹，有時甚至會適得其反。本文將深入探討資料庫設計與 SQL 調優，幫助你理解查詢背後的原理，從根本解決效能問題。

## 索引不是萬靈丹

索引的確能加速查詢，但並非所有情況都適用。理解索引的種類與運作方式至關重要。

### B-Tree 索引

B-Tree 是最常見的索引類型。它是一種平衡樹結構，能快速定位到目標資料。但 B-Tree 索引也有其限制：

*   **適用範圍**：適合等值查詢（`=`, `IN`）、範圍查詢（`>`, `<`, `BETWEEN`）、以及前綴匹配（`LIKE 'prefix%'`）。
*   **不適用範圍**：不適合 `LIKE '%suffix'` 或 `LIKE '%middle%'` 這種模式匹配，因為需要掃描整個索引。
*   **排序**：B-Tree 索引本身是有序的，所以可以加速 `ORDER BY` 操作。

### Covering Index (覆蓋索引)

當索引包含查詢所需的所有欄位時，資料庫可以直接從索引中取得資料，而無需回表查詢（也就是不需要再根據索引找到的 row id 去 table 裡撈取其他欄位）。這能大幅提升效能。

### 過多索引的副作用

索引會佔用儲存空間，並且在資料寫入時需要維護索引，這會降低寫入效能。此外，查詢優化器在選擇索引時也需要時間，過多的索引反而會增加優化器的負擔。

**最佳實踐**：只建立必要的索引，並定期檢查未使用或重複的索引。

### 案例分析：使用 `EXPLAIN` 診斷查詢效能

假設我們有一個 `users` 表格，包含 `id`, `name`, `email`, `created_at` 等欄位。現在需要查詢所有在特定時間範圍內註冊的使用者：

```sql
SELECT id, name, email FROM users WHERE created_at BETWEEN '2023-01-01' AND '2023-01-31';
```

如果沒有 `created_at` 索引，這個查詢會進行全表掃描 (full table scan)。我們可以透過 `EXPLAIN` 指令來查看查詢計畫：

```sql
EXPLAIN SELECT id, name, email FROM users WHERE created_at BETWEEN '2023-01-01' AND '2023-01-31';
```

`EXPLAIN` 的輸出會顯示查詢使用的索引、掃描的行數等資訊。如果看到 `type: ALL`，表示進行了全表掃描，這通常是效能瓶頸。

解決方案：建立 `created_at` 索引。

```sql
CREATE INDEX idx_users_created_at ON users (created_at);
```

建立索引後，再次執行 `EXPLAIN`，應該會看到 `type: range` 或 `type: index_range`，表示查詢使用了索引，效能會大幅提升。如果我們建立 `created_at` 和 `name` 的複合索引，並且查詢只 select `id`, `name`, `created_at`，那就會用到 covering index，效能會更好。

## 正規化 vs 反正規化

資料庫正規化旨在減少資料冗餘，提高資料一致性。但過度正規化會導致查詢需要 JOIN 多個表格，降低效能。反正規化則是透過增加資料冗餘來減少 JOIN 操作。

**何時該反正規化？**

*   **讀取頻率遠高於寫入頻率**：例如，商品資訊經常被讀取，但很少被修改。
*   **JOIN 操作成為效能瓶頸**：當 JOIN 操作佔據了查詢的大部分時間時。
*   **資料一致性要求不高**：例如，統計報表允許一定程度的資料延遲。

**反正規化的策略**

*   **增加冗餘欄位**：在一個表格中複製另一個表格的欄位。
*   **建立匯總表格**：定期計算並儲存匯總資料。

**權衡考量**

反正規化會增加資料冗餘，可能導致資料不一致。因此，需要在效能和資料一致性之間做出權衡。

## N+1 問題與批次查詢

N+1 問題是 ORM 使用者最常遇到的效能陷阱。它指的是在查詢一個父物件時，需要額外進行 N 次查詢來獲取其關聯的子物件。

**情境**：假設我們有一個 `posts` 表格和一個 `comments` 表格，一個 `post` 可以有多個 `comment`。

**產生 N+1 查詢的 ORM 寫法 (Python SQLAlchemy)**

```python
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Post(Base):
    __tablename__ = 'posts'
    id = Column(Integer, primary_key=True)
    title = Column(String)
    comments = relationship("Comment", back_populates="post")

class Comment(Base):
    __tablename__ = 'comments'
    id = Column(Integer, primary_key=True)
    text = Column(String)
    post_id = Column(Integer, ForeignKey('posts.id'))
    post = relationship("Post", back_populates="comments")

engine = create_engine('sqlite:///:memory:') # Use an in-memory SQLite database for example
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

# Create some sample data
post1 = Post(title="First Post")
post2 = Post(title="Second Post")
comment1 = Comment(text="Comment 1 on Post 1", post=post1)
comment2 = Comment(text="Comment 2 on Post 1", post=post1)
comment3 = Comment(text="Comment 1 on Post 2", post=post2)
session.add_all([post1, post2, comment1, comment2, comment3])
session.commit()


posts = session.query(Post).all()
for post in posts:
    print(f"Post: {post.title}")
    for comment in post.comments:  # N+1 problem here
        print(f"  - Comment: {comment.text}")

session.close()
```

這段程式碼會先查詢所有 `post`，然後針對每個 `post`，再查詢其關聯的 `comment`。如果 `post` 的數量是 N，那麼總共會執行 N+1 次查詢。

**使用 eager loading 優化後的版本 (Python SQLAlchemy)**

```python
from sqlalchemy.orm import joinedload

posts = session.query(Post).options(joinedload(Post.comments)).all()  # Eager loading
for post in posts:
    print(f"Post: {post.title}")
    for comment in post.comments:
        print(f"  - Comment: {comment.text}")

session.close()
```

透過 `joinedload(Post.comments)`，我們告訴 SQLAlchemy 在查詢 `post` 的同時，也一併載入其關聯的 `comment`。這樣只需要一次查詢就能取得所有需要的資料，避免了 N+1 問題。

**使用 raw SQL 優化 (PostgreSQL)**

```sql
SELECT p.id, p.title, c.id as comment_id, c.text
FROM posts p
LEFT JOIN comments c ON p.id = c.post_id;
```

使用 raw SQL 可以更精確地控制查詢，避免 ORM 產生的額外開銷。但需要注意 SQL 注入等安全問題。

**結論**

理解資料庫的運作原理，才能寫出高效能的查詢。不要盲目地加索引，而是要分析查詢計畫，找出效能瓶頸。在正規化和反正規化之間做出權衡，並避免 N+1 問題。從 Junior 晉升為 Senior，需要的不僅僅是 CRUD 能力，更是對底層原理的深入理解。資料庫不是黑盒子，而是後端工程師必須掌握的基本功。
